# java-chicken-2019
## Introduction

![chicken](https://user-images.githubusercontent.com/35681772/76184197-58606d00-620e-11ea-8ffd-1257ec33d8ed.gif)

이 프로젝트는 우아한 형제들의 '2019 우아한 테크코스' 의 오프라인 코딩 테스트 과제였습니다. 
이를 시간이 지난 후에 TDD 를 연습하기 위한 목적으로 다시 개발 해 보았습니다.

### 기능 요구사항
 * 치킨집 사장님이 사용하는 간단한 포스(POS) 프로그램을 구현한다.   주문등록, 결제하기, 프로그램 종료 기능을 가진다.
 * 메뉴 기본 정보가 주어지며 메뉴 번호, 종류, 이름, 가격을 가진다.
 * 테이블 기본 정보가 주어지며 테이블 번호를 가진다.
 * 한 테이블에서 주문할 수 있는 한 메뉴의 최대 수량은 99개이다.
 * 주문이 등록된 테이블은 결제가 이루어지기 전까지 테이블 목록에 별도로 표시한다.
 * 주문 내역에 대한 계산을 할 때는 결제 유형에 따라 할인율이 달라진다.
   - 치킨 종류 메뉴의 수량 합이 10개가 넘는 경우 10,000원씩 할인된다.
     - e.g. 10개는 10,000원 할인, 20개는 20,000원 할인
   - 현금 결제는 5%가 할인되며 할인된 금액에서 한 번 더 할인이 가능하다.
 * 주문 혹은 결제가 불가능한 경우 그 이유를 보여 주고, 다시 주문 혹은 결제가 가능하도록 해야 한다.
 * 최종 결제 금액을 보여준다.
 
### 기술 스택
 * Java 를 사용한 콘솔 프로젝트
 * Using Gradle for build tool
 * Add Junit5, Mockito for test

__Java__ 로 개발하는 것이 프로젝트의 요구사항이었습니다. 
Java 는 객체 지향적 언어이기 때문에, OOP(Object-Oriented Programming) 의 관점에서 프로젝트를 설계하고 개발하는 것을 연습해보기에 적합하다고 생각했습니다.
뿐만 아니라 운영체제에 독립적이고, Garbage Collector 를 이용한 자동 메모리 관리, 멀티 쓰레드 제공 등 Java 가 가지는 여러 장점들이 있습니다. 
오랜 기간 사용되며 발전고 있는 언어이기 때문에 다양한 라이브러리와 프레임워크를 사용할 수 있어 보다 빠른 개발이 가능하다는 장점도 있습니다.

Java 의 빌드 툴에는 대표적으로 Maven 과 Gradle 이 있습니다. 
__Gradle__ 은 Maven 의 장점을 모아 더 나중에 출시되었으며 Android OS의 빌드 툴로 채택 되었습니다.
뿐만 아니라, Maven 에서 사용하는 XML 형식을 개선하여 Groovy 스크립트를 사용한 build 를 제공하기 때문에 가독성 측면에서 우수합니다.
[Gradle 은 Maven 보다 최대 100배 빠른 퍼포먼스를 보여줄 수 있다는 비교 결과가 있습니다.](https://gradle.org/gradle-vs-maven-performance/)

<img width="640" alt="gradle_versus_maven" src="https://user-images.githubusercontent.com/35681772/79683439-20b10000-8265-11ea-9d3d-690e93522459.png">

> 출처 : https://gradle.org/gradle-vs-maven-performance/

테스트를 위해 __Junit5__ 를 사용하였는데, Junit4 은 하나의 Jar 파일이지만 Junit5 은 JUnit Platform, JUnit Jupiter, JUnit Vintage 이 3가지 모듈로 나뉘어 있습니다.
뿐만 아니라 테스트 작성자를 위한 API 모듈과 테스트 실행을 위한 API 가 분리되어 있습니다. 따라서 보다 Compact 한 테스트를 수행할 수 있습니다.
Junit5 에서는 Junit4 에서 제공하는 대부분의 기능들을 차용하며, Lambda Expression 등 Java 8 이상에서 제공하는 기능들을 함께 사용할 수 있어 더 다양한 방법으로 테스트를 작성할 수 있습니다.

__Mockito__ 는 테스트를 작성함에 있어 얽혀있는 의존성으로부터 좀 더 간편하게 테스트 하기 위해 사용했습니다.
Mockito 는 자바에서 단위테스트를 하기 위해 Mock 을 만들어주는 프레임워크입니다.
Mock 이라는 단어의 사전적 의미에서 알 수 있듯, Mocking 이란 의존성을 지닌 객체에서의 테스트에 있어 해당 의존성에 대해 가짜 객체를 만들어 행위에 대한 시뮬레이션을 적용하여 사용하는 것을 말합니다.
의존성의 제약을 받지 않고, 보다 compact 한 테스트를 작성하기 위해 Mockito 를 사용하였습니다. 

---

## chickenPOS Project Architecture
chickenPOS 는 OOP(Object-Oriented Programming) 의 관점에서 개발하려고 노력했습니다.
OOP 는 여러 해석이 있고 바라보는 관점의 차이도 존재하지만, 
조영호 개발자님이 기술한 [오브젝트](https://book.naver.com/bookdb/book_detail.nhn?bid=15007773), [객체지향의 사실과 오해](https://book.naver.com/bookdb/book_detail.nhn?bid=9145968) 에서 설명하고 있는
__역할과 책임을 바탕으로 협력 공동체를 만드는__ 관점을 적용하여 보다 신중하게 설계하려고 노력하였습니다.
   
또한 콘솔 단과 비즈니스 로직을 분리하여 추후에 이것이 웹 프로젝트로 변경되더라도 도메인은 변화가 없도록 설계하였습니다.

<img width="958" alt="chicken_level" src="https://user-images.githubusercontent.com/35681772/79725167-c9be3000-8323-11ea-9b8d-4e3a1f3315d6.png">

> 인터페이스를 이용해서 구현한 POSProcessor 계층

POSProcessor 계층은 제공하는 기능을 인터페이스를 사용하여 구현하였습니다. 
그렇게 해서 나중에 새로운 기능(예를 들어 주문 수정과 같은)이 추가 되더라도, 기존 코드의 수정 없이 기능을 추가하여 사용할 수 있습니다.

마찬가지로, 결제 기능에서 사용되는 할인 정책에 관련된 DiscountPolicy 계층도 인터페이스를 사용하여 구현하였으므로, 또 다른 할인 정책이 추가되더라도 코드 수정 없이 새로운 정책을 추가할 수 있습니다.

OOP의 핵심 가치중 하나인 다형성을 고려하여 설계하여 확장과 변경에 유연한 구조를 가지도록 노력하였습니다.

### Domain
#### 제공된 도메인
 * Category
 * Menu
 * MenuRepository
 * Table
 * TableRepository
  
#### 추가한 도메인
 * Order : 주문 내역을 나타내며 메뉴와 수량을 알고 있습니다. 또한 테이블은 주문 내역을 알고 있기 때문에 해당 테이블의 결제 전까지 별도의 표시가 됩니다.
 * DiscountAgency : 할인을 담당합니다. 할인 정책을 알고 있으며 이를 바탕으로 할인된 금액을 계산합니다.
 * DiscountPolicy : 기능 요구사항을 반영하여 두 가지 할인 정책을 도출하였습니다. 
 * PaymentMethod : 요구사항에 제시된 결제 수단을 반영하였습니다.
 * POSProcessor : 기능 요구사항을 바탕으로 제공할 기능을 Processor 로 분리하였습니다. 따라서 추후에 기능이 추가되더라도 기존 코드는 별도의 수정이 필요하지 않습니다.
 * POSCommand : 제공되는 기능을 나타냅니다.
 * POSMachine : 사용자로부터 종료 요청을 받기 전 까지 계속 실행되는 서비스를 반영하였습니다.

### 기능 목록
 * 샤용자에게 기능을 입력받고 해당 기능을 실행해야 한다.
 * 주문등록의 경우 사용자에게 테이블 번호, 메뉴, 수량을 입력받는다.
   - 주문은 메뉴와 수량을 알고 있다.
   - 테이블은 주문 내역을 알고 있다.
 * 이 때, 지원하지 않는 번호가 입력된 경우 예외를 던진다.
 * 한 테이블에서 한 메뉴에 대해 99개를 초과하여 주문하려는 경우 예외를 던진다.
 * 주문이 등록된 테이블은 결제가 이루어지기 전까지 테이블 목록에 별도로 표시한다.
 * 결제하기의 경우 결제할 테이블을 선택하면 해당 테이블의 주문 내역을 보여주고 결제를 진행한다.
 * 이 때, 지원하지 않는 번호가 입력되거나, 입력한 테이블에 주문 내역이 없는 경우 예외를 던진다.
 * 결제는 주문 내역과 결제 수단을 고려하여 최종 결제할 금액을 보여준다.
 
--- 

## Achievement
'2019 우아한 테크코스' 최종 미션에서 탈락한 이유를 __테스트 코드 미작성, 신중하지 않았던 커밋 및 커밋 로그 작성, 불필요한(과도한) 설계 및 구현__ 이 3가지로 분석했습니다.
그래서 다시 프로젝트를 진행하며 이를 개선하기 위해 다음과 같은 노력했습니다.

#### TDD(Test-Driven-Development) 로 개발을 하며 유연한 설계에 대한 충분한 고민을 하게되었고, SRP(Single-Responsibility-Principle)를 준수하는 코드를 작성할 수 있게 됨
TDD 로 테스트를 먼저 작성하면서 자연스럽게 설계에 대한 고민을 하게 되었습니다.
어떤 객체끼리 협력 관계를 맺어줄 지, 불필요한 의존을 하는것은 아닌지 구현에 앞서 생각해 보게 되었습니다.
그러면서 테스트 하기 어려운 코드는 좋은 코드라고 보기 어렵다고 생각하게 되는 계기가 되었습니다. 
따라서 프로젝트를 진행하며 테스트 코드 작성이 쉽지 않을 땐 설계가 잘못된 것은 아닌지, 분리해 낼 관심은 없는지 고민하며 개선하게 되었습니다. 
결과적으로 SRP 를 준수하며 하나의 역할만 잘 수행하는 코드를 작성할 수 있게 되었습니다.

#### Karma commit style 을 적용하여 일관성 있는 commit log 를 작성할 수 있도록 개선, 역할 별로 commit 을 하여 보다 직관적이고 유의미한 메세지를 작성
이전까지는 commit 을 신중하게 하지 않았으나, 이 프로젝트를 계기로 commit 을 어떤 단위로 할 지에 대해 고민하게 되었습니다.
그래서 코드를 작성하거나 변경할 때 마다 역할을 기준으로 커밋을 하며 Karma commit style 을 적용하여 해당 commit 이 어떤 것을 반영하는지 자세하게 적으려고 노력했습니다.

#### 기능 목록을 작성하여 필요한 역할들을 선별하였고 이를 반영하여 협력 공동체를 만들기 위해 노력
곧바로 구현에 들어가지 않고 요구 사항을 만족하는 기능을 제공하기 위해 어떤 기능들이 필요한지 기능 목록을 작성하는데에 오랜 시간을 투자했습니다.
구현 해야할 기능들을 세분화 하며 역할을 분리해 냈고 그 기능 목록을 기준으로 개발을 시작했습니다.
구현을 하며 맞닥뜨리는 기능 목록의 변경에 대해 이를 반영하여 개선 및 수정해 나갔고, 살아있는 문서로 만들었습니다.
이런 방식으로 섣불리 구현부터 시작해 불필요한 코드를 작성하던 습관을 개선하게 되었습니다.

---